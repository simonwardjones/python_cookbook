[{"title": "Scopes", "author": "Simon Ward-Jones", "snippet": "a = 1\n\n\ndef f():\n    \"\"\"\n    Uses global because there is no local 'a'\n    \"\"\"\n    print('Inside f() : ', a)\n\n\ndef g():\n    \"\"\"\n    Variable 'a' is redefined as a local\n    \"\"\"\n    a = 2\n    print('Inside g() : ', a)\n\n\ndef h():\n    \"\"\"\n    Uses global keyword to modify global 'a'\n    \"\"\"\n    global a\n    a = 3\n    print('Inside h() : ', a)\n\n# If we did not incluse the 'global' keyword\n# we would receive this error:\n# \"UnboundLocalError: local variable 'a' referenced before assignment\"\n\n\nprint('global : ', a)\nf()\nprint('global : ', a)\ng()\nprint('global : ', a)\nh()\nprint('global : ', a)\n\n# global :  1\n# Inside f() :  1\n# global :  1\n# Inside g() :  2\n# global :  1\n# Inside h() :  3\n# global :  3", "description": "Demonstrating Scopes", "section": "Scopes", "tags": ["global", "local", "scopes"]}, {"title": "Dataframe indexing", "author": "Simon Ward-Jones", "snippet": "import pandas as pd\nimport numpy as np\nimport random\nfrom datetime import datetime\nfrom dateutil.relativedelta import relativedelta\n\n# First we create example dataframe\nr = random.Random(12)\n\n\ndef generate_random_date_in_last_year():\n    return (datetime.now() - relativedelta(days=365 * random.random()))\n\n\ndataframe = pd.DataFrame({\n    \"date_time\": [generate_random_date_in_last_year() for _ in range(10)],\n    \"animal\": ['zebra', 'zebra', 'zebra', 'zebra', 'lion', 'lion', 'lion',\n               'lion', 'rhino', 'rhino', ],\n    \"category\": ['stripy'] * 4 + ['dangerous'] * 6,\n    \"name\": ['Walter', 'Edmund', 'Gyles', 'John', 'Bartholomew', 'Frederyk',\n             'Raulf', 'Symond', 'Carlos', 'Arthur'],\n    \"weight\": [80 + 40 * r.random() for _ in range(10)],\n    \"favourite_integer\": [r.randint(0, 100) for _ in range(10)],\n    \"bad_column\": ['', 3, '', 1, None, 2, 23, 2, 3, 3],\n    'employed': [bool(r.randint(0, 1)) for i in range(10)]\n})\ndataframe.replace(to_replace='', value=np.nan, inplace=True)\n\n# How to get the value in row zero in the 'name' column\n\nidx = 0\n\n# All the below give the same result\n\n# Using .loc to select row and column\ndataframe.loc[idx, 'name']\n# 'Walter'\n\n# Select the row then name\n# Use .iloc to select a row series and then select name entry\ndataframe.iloc[idx]['name']\n# 'Walter'\n\n# Select the column series and then select the idx entry\ndataframe['name'][idx]\n# 'Walter'\n\n# Same but with dot notation\ndataframe.name[idx]\n# 'Walter'", "description": "Dataframe indexing", "section": "Pandas", "tags": ["pandas", "index", "lookup"]}, {"title": "Run subprocess", "author": "Simon Ward-Jones", "snippet": "import subprocess\nfrom subprocess import run\n\nstring_to_do = [\"sleep 1; echo 'A wild Zebra!!'\"]\n\n# As of python 3.5 it is best to use the run command\n# The are many options - see docs for full details\nout = run(string_to_do,\n          check=False,  # Do not error if subprocess returns non-zero\n          stdout=subprocess.PIPE,  # Pipe value to stdout\n          shell=True)  # Complete as shubshell command\n\nprint(str(out.stdout, 'utf-8'))", "description": "How to run a subprocess", "section": "Os", "tags": ["os", "subprocess"]}, {"title": "Dataframe datetime", "author": "Simon Ward-Jones", "snippet": "import pandas as pd\nimport random\nfrom datetime import datetime\nfrom dateutil.relativedelta import relativedelta\n\n# First we create example dataframe\nr = random.Random(12)\n\n\ndef generate_random_date_in_last_year():\n    return (datetime.now() - relativedelta(days=365 * random.random()))\n\n\ndataframe = pd.DataFrame({\n    \"date_time\": [generate_random_date_in_last_year() for _ in range(10)]})\ndataframe['month'] = dataframe.date_time.dt.month\ndataframe['day'] = dataframe.date_time.dt.day\ndataframe['hour'] = dataframe.date_time.dt.hour\ndataframe['minute'] = dataframe.date_time.dt.minute\ndataframe['day_of_week'] = dataframe.date_time.dt.dayofweek\n\ndataframe\n#   | date_time                  | month | day | hour | minute | day_of_week\n# 0 | 2017-06-01 16:52:55.692476 | 6     | 1   | 16   | 52     | 3\n# 1 | 2017-06-15 04:19:29.499383 | 6     | 15  | 4    | 19     | 3\n# 2 | 2017-08-31 14:48:38.406128 | 8     | 31  | 14   | 48     | 3\n# 3 | 2017-06-06 23:46:50.090056 | 6     | 6   | 23   | 46     | 1\n# 4 | 2018-03-01 04:08:46.937911 | 3     | 1   | 4    | 8      | 3\n# 5 | 2017-03-14 11:36:48.532703 | 3     | 14  | 11   | 36     | 1\n# 6 | 2017-10-19 22:47:44.591292 | 10    | 19  | 22   | 47     | 3\n# 7 | 2017-06-23 03:39:29.668738 | 6     | 23  | 3    | 39     | 4\n# 8 | 2017-09-15 05:33:02.847853 | 9     | 15  | 5    | 33     | 4\n# 9 | 2017-06-19 01:41:20.161772 | 6     | 19  | 1    | 41     | 0", "description": "Dataframe datetime", "section": "Pandas", "tags": ["pandas", "datetime", "timestamp"]}, {"title": "Object creation", "author": "Simon Ward-Jones", "snippet": "class A:\n    pass\n\na = A()\n\nprint(f'a.__class__ = {a.__class__}')\nprint(f'A.__class__ = {A.__class__}')\n# a.__class__ = <class '__main__.A'>\n# A.__class__ = <class 'type'>\n\n# What just happened? No really what happened?\n# We created a class then an instanc but how did that happen\n\n#####################\n# Instance creation\n#####################\nprint('Instance creation')\n\n# 1 - The MetaClass.__call__ function is called which does two things**\n#     1.1 - Calls Class.__new__ returning an object\n#     1.2 - Calls Class.__init__ returning initialised object\n# The instance is the returned\n\n## We can override these magic functions to see this.\n# Note the default MetaClass is type\n\n# First we create a metaclass and override __call__\nclass MetaExample(type):\n  def __call__(cls, *args, **kwargs):\n         print(f'MetaExample __call__\\n'\n               f'\\tcls = {cls}\\n\\targs = {args}\\n\\tkwargs = {kwargs}')\n         return super().__call__(*args, **kwargs)\n\n# Now we create the Class and override __new__ and __init__\nclass Example(metaclass=MetaExample):\n    def __init__(self,*args, **kwargs):\n        print('Example.__init__\\n',\n              f'\\tself = {self}\\n\\targs = {args}\\n\\tkwargs = {kwargs}')\n        super().__init__()\n    def __new__(self, *args, **kwargs):\n        print('Example.__new__\\n'\n              f'\\tself = {self}\\n\\targs = {args}\\n\\tkwargs = {kwargs}')\n        return super().__new__(self)\n\n\nexample_instance = Example(1, a='string')\n\n# MetaExample __call__\n#   cls = <class '__main__.Example'>\n#   args = (1,)\n#   kwargs = {'a': 'string'}\n# Example.__new__\n#   self = <class '__main__.Example'>\n#   args = (1,)\n#   kwargs = {'a': 'string'}\n# Example.__init__\n#   self = <__main__.Example object at 0x1104ce710>\n#   args = (1,)\n#   kwargs = {'a': 'string'}\n\n\n\n#####################\n# Class creation\n#####################\nprint('\\nClass creation')\n\n# 1 - the MetaClass __prepare__ fumnction is called providing a namespace dict\n# 2 - The MetaMetaClass.__call__ function is called which does two things\n#     2.1 - Calls MetaClass.__new__ returning a Class object\n#     2.2 - Calls MetaClass.__init__ returning initialised Class\n\nclass MetaMetaClass(type):\n    def __call__(mcls, *args, **kwargs):\n        print(f'MetaMetaClass __call__\\n'\n              f'\\tmcls = {mcls}\\n\\targs = {args}\\n\\tkwargs = {kwargs}')\n        cls = mcls.__new__(mcls, *args, **kwargs)\n        mcls.__init__(cls, *args, **kwargs)\n        return cls\n        # this mimics the standard\n        # return super().__call__(*args, **kwargs)\n\n\nclass MetaClass(type, metaclass=MetaMetaClass):\n    def __new__(cls, name, bases, namespace, *args, **kwargs):\n        print('MetaClass.__new__\\n'\n              f'\\tcls = {cls}\\n'\n              f'\\tname = {name}\\n\\tbases = {bases}\\n\\tnamespace = {namespace}')\n        return super().__new__(cls, name, bases, namespace)\n\n    def __init__(self, *args, **kwargs):\n        print(f'MetaClass.__init__\\n\\tself = {self}')\n\n\nclass Example(metaclass=MetaClass):\n    pass\n\n# Class creation\n# MetaMetaClass __call__\n#   mcls = <class '__main__.MetaClass'>\n#   args = ('Example', (), {'__module__': '__main__', '__qualname__': 'Example'})\n#   kwargs = {}\n# MetaClass.__new__\n#   cls = <class '__main__.MetaClass'>\n#   name = Example\n#   bases = ()\n#   namespace = {'__module__': '__main__', '__qualname__': 'Example'}\n# MetaClass.__init__\n#   self = <class '__main__.Example'>\n\n# Note the class object now exists\n# Also see __new__ and __init__ are static\n\nprint(Example)\n\n# Just to blow you mind the statement:\n# class Example(metaclass=MetaClass):\n#     pass\n# could be replaced with\n# Example = MetaMetaclass.__call__(MetaClass,'Example', (), {})\n\n# Note\n# type('Example',(),{})\n# is type.__call__(type,'Example',(),{})", "description": "instance and Class creation", "section": "Objects", "tags": ["instance", "creation", "class", "__new__", "__init__", "__prepare__"]}, {"title": "Sqlalchemy declarative base", "author": "Simon Ward-Jones", "snippet": "from sqlalchemy import (Column, DateTime, String, Integer, ForeignKey,\n                        func, Boolean, create_engine)\nfrom sqlalchemy.orm import relationship, backref\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.sql.expression import false, true\nfrom sqlalchemy.orm import sessionmaker\n\nBase = declarative_base()\n\n\nclass Parent(Base):\n    __tablename__ = 'parents'\n    id = Column(Integer, primary_key=True)\n    name = Column(String(255), unique=True)\n    children = relationship('Child',\n                            secondary='association',\n                            back_populates='parents')\n\n    def __repr__(self):\n        return f'Parent(name={self.name})'\n\n\nclass Child(Base):\n    __tablename__ = 'children'\n    id = Column(Integer, primary_key=True)\n    name = Column(String(255), unique=True)\n    parents = relationship('Parent',\n                           secondary='association',\n                           back_populates='children')\n\n    def __repr__(self):\n        return f'Child(name={self.name})'\n\n\nclass Association(Base):\n    __tablename__ = 'association'\n    parent_id = Column(Integer, ForeignKey('parents.id'), primary_key=True)\n    child_id = Column(Integer, ForeignKey('children.id'), primary_key=True)\n    good_relationsip = Column(Boolean, server_default=true())\n    parent = relationship(\"Parent\", backref='parent_child_association')\n    child = relationship(\"Child\", backref='child_parent_association')\n\n    def __repr__(self):\n        return f'Association({self.parent})<==>{self.child})'\n\n\n# Create the database (in memory)\nengine = create_engine('sqlite://', echo=False)\n# turn echo to True to print sql as it runs\nBase.metadata.bind = engine\nBase.metadata.create_all()\n\n# sql\n# CREATE TABLE parents (\n#     id INTEGER NOT NULL,\n#     name VARCHAR(255),\n#     PRIMARY KEY (id),\n#     UNIQUE (name)\n# )\n# CREATE TABLE children (\n#     id INTEGER NOT NULL,\n#     name VARCHAR(255),\n#     PRIMARY KEY (id),\n#     UNIQUE (name)\n# )\n# CREATE TABLE association (\n#     parent_id INTEGER NOT NULL,\n#     child_id INTEGER NOT NULL,\n#     good_relationsip BOOLEAN DEFAULT 1,\n#     PRIMARY KEY (parent_id, child_id),\n#     FOREIGN KEY(parent_id) REFERENCES parents (id),\n#     FOREIGN KEY(child_id) REFERENCES children (id),\n#     CHECK (good_relationsip IN (0, 1))\n# )\n\n# Define obejcts\nrichard = Child(name='Richard')\npaul = Child(name='Paul')\nsimon = Child(name='Simon')\nann = Parent(name='Ann')\nstephen = Parent(name='Stephen')\n\n# So lets add our work to the db\nSession = sessionmaker(bind=engine)\nsession = Session()\n\nfor item in [ann, stephen, richard, paul, simon]:\n    session.add(item)\nsession.commit()\n# sample sql:\n# INSERT INTO children (name) VALUES (?)\n# ('Richard',)\n\n\n# set the family up (the relations)\nfor child in [richard, paul, simon]:\n    ann.children.append(child)\n    stephen.children.append(child)\n\n# extra detail:\n# Having defined the back_poulates we can use these properties as expected\n# before having commited to the db (via session.commit())\nprint(f'Ann has children: {ann.children}')\n\n# However the association objects have not been created yet\nsession.commit()\n# sql\n# INSERT INTO association (parent_id, child_id) VALUES (?, ?)\n# ((1, 2), (1, 3), (2, 1), (2, 2), (2, 3))\n\n# Now that the associations have been created we can inspect one\n# also demonstrating the querying\nquery = session.query(Association) \\\n               .join(Parent) \\\n               .join(Child) \\\n               .filter(Parent.name == 'Ann') \\\n               .filter(Child.name == 'Simon')\nann_simon = query.one()\n\nprint(f'ann_simon object has __repr__: {ann_simon} and they do'\n      f'{\"not\" if not ann_simon.good_relationsip else \"\" } get on')\n# ann_simon object has __repr__:\n# Association(Parent(name=Ann))<==>Child(name=Simon)) and they do get on\n\n\n# We can take this example further let's add Toys but only for the\n# children. lets make it many toy for each child. let's assume they\n# are selfish and a toy can only have one child\n\nclass Toy(Base):\n    __tablename__ = 'toys'\n    id = Column(Integer, primary_key=True)\n    child_id = Column(Integer, ForeignKey('children.id'))\n    name = Column(String(255), unique=True)\n    child = relationship('Child', backref='toys')\n\n    def __repr__(self):\n        return f\"Toy(name={self.name})\"\n\n\n# Make the new table\nToy.__table__.create()\n\nfootball = Toy(name='Football')\nplaystation = Toy(name='playstation')\nbat = Toy(name='bat')\n\nrichard.toys.append(football)\nrichard.toys.append(playstation)\nbat.child = paul\n\nsession.commit()\n\nprint(f'bat belongs to {bat.child}')\n# bat belongs to Child(name=Paul)\nprint(f'Richard has toys {richard.toys}')\n# Richard has toys [Toy(name=Football), Toy(name=playstation)]\n\n# Comin full circle let's define a one-to-one relationship\n# let's add nicknames as a one-to-one\n\n\nclass Nickname(Base):\n    __tablename__ = 'nicknames'\n    id = Column(Integer, primary_key=True)\n    child_id = Column(Integer, ForeignKey('children.id'))\n    nickname = Column(String(255), unique=True)\n    child = relationship('Child', backref=backref(\"nickname\", uselist=False))\n\n    def __repr__(self):\n        return self.nickname\n\n    def __str__(self):\n        return self.nickname\n\n\n# Make the new table\nNickname.__table__.create()\n\nSi = Nickname(nickname='Si')\nRich = Nickname(nickname='Rich')\nsimon.nickname = Si\nprint(f'simon has nickname {simon.nickname} of type {type(simon.nickname)}')\n# simon has nickname Si of type <class '__main__.Nickname'>", "description": "An example defining a many to many relationship using an association\n    class and then a many-to-one relationship and finally a one-to-one\n    relationship", "section": "Sqlalchemy", "tags": ["sqlalchemy", "table", "declarative_base", "many-to-many"]}, {"title": "S3 boto read file", "author": "Carlos Aguilar (Simon Ward-Jones)", "snippet": "import boto3\nimport pickle\n\nbucket = 'amazon-sagemaker-poc'\nregion = boto3.Session().region_name\ns3Client = boto3.client('s3')\nbucketList = s3Client.list_objects_v2(Bucket=bucket)\n\n# To retrieve the full list of keys\nbucketContents = [currentKey['Key'] for currentKey in bucketList['Contents']]\nprint(bucketContents)\n\n# To read an object\nkeyName = 'tpsPurchases.pickle'\nobj = s3Client.get_object(Bucket=bucket, Key=keyName)\n\ndfFromPickle = pickle.loads(obj['Body'].read())\nprint(dfFromPickle.shape)", "description": "Read a file from S3", "section": "Reading And Writing", "tags": ["read", "s3", "boto3"]}, {"title": "Aggregate dataframe", "author": "Simon Ward-Jones", "snippet": "import pandas as pd\nimport numpy as np\nimport random\nfrom datetime import datetime\nfrom dateutil.relativedelta import relativedelta\n\n# First we create example dataframe\nr = random.Random(12)\n\n\ndef generate_random_date_in_last_year():\n    return (datetime.now() - relativedelta(days=365 * random.random())).date()\n\n\ndataframe = pd.DataFrame({\n    \"date_time\": [generate_random_date_in_last_year() for _ in range(10)],\n    \"animal\": ['zebra', 'zebra', 'zebra', 'zebra', 'lion', 'lion', 'lion',\n               'lion', 'rhino', 'rhino', ],\n    \"category\": ['stripy'] * 4 + ['dangerous'] * 6,\n    \"name\": ['Walter', 'Edmund', 'Gyles', 'John', 'Bartholomew', 'Frederyk',\n             'Raulf', 'Symond', 'Carlos', 'Arthur'],\n    \"weight\": [80 + 40 * r.random() for _ in range(10)],\n    \"favourite_integer\": [r.randint(0, 100) for _ in range(10)],\n    \"bad_column\": ['', 3, '', 1, None, 2, 23, 2, 3, 3],\n    'employed': [bool(r.randint(0, 1)) for i in range(10)]\n})\ndataframe.replace(to_replace='', value=np.nan, inplace=True)\ndataframe\n\ndataframe_stats = dataframe.groupby(['animal', 'employed']).agg({\n    'favourite_integer': ['min', 'max', 'mean', 'std', 'sum'],\n    'weight': ['sum']})\n\nanimal_weight_stats = dataframe_stats['weight'].sort_values('sum',\n                                                            ascending=False)\n\nanimal_weight_stats\n\n# animal | employed | sum\n# zebra  | False    | 311.93814609882565\n# lion   | False    | 298.3660273510712\n# rhino  | False    | 211.68198767065672\n# zebra  | True     | 85.70401411701471\n# lion   | True     | 80.43441772360272\n\n# Ineresting that the unemployed animals are heavier!", "description": "Dataframe aggregations", "section": "Pandas", "tags": ["pandas", "aggregate", "sum", "mean"]}, {"title": "Nonlocal", "author": "Simon Ward-Jones", "snippet": "# Example 1) local variables\na = 1\n\n\ndef f():\n    def g():\n        a = 3\n        print(f'a in g: {a}')\n    a = 2\n    print(f'a in f before g called: {a}')\n    g()\n    print(f'a in f after g called: {a}')\n\n\nprint(f'a before f called: {a}')\nf()\nprint(f'a after f called: {a}')\nprint()\n\n# a before f called: 1\n# a in f before g called: 2\n# a in g: 3\n# a in f after g called: 2\n# a after f called: 1\n\n# The vairables scopes are all separate and hence not changed\n\n\n# Example 2) global variables\na = 1\n\n\ndef f():\n    def g():\n        global a\n        a = 3\n        print(f'a in g: {a}')\n    global a\n    a = 2\n    print(f'a in f before g called: {a}')\n    g()\n    print(f'a in f after g called: {a}')\n\n\nprint(f'a before f called: {a}')\nf()\nprint(f'a after f called: {a}')\nprint()\n\n# a before f called: 1\n# a in f before g called: 2\n# a in g: 3\n# a in f after g called: 3\n# a after f called: 3\n\n# The a variable always refers to the global!\n# See that all variables were changed by assignment in g\n\n\n# Example 3) nonlocal variables\na = 1\n\n\ndef f():\n    def g():\n        nonlocal a\n        a = 3\n        print(f'a in g: {a}')\n    a = 2\n    print(f'a in f before g called: {a}')\n    g()\n    print(f'a in f after g called: {a}')\n\n\nprint(f'a before f called: {a}')\nf()\nprint(f'a after f called: {a}')\nprint()\n\n# a before f called: 1\n# a in f before g called: 2\n# a in g: 3\n# a in f after g called: 3\n# a after f called: 1\n\n# The nonlocal a variable refers to the variable defined in the\n# local f function scope (more generally one level above)\n# nonloal can not be used to refer to module level variable\n\n\n# Example 4) A more complex example\na = 1\n\n\ndef f():\n    def g():\n        def h():\n            global a\n            a = 4\n            print(f'a in h {a}')\n        nonlocal a\n        a = 3\n        print(f'a in g before h: {a}')\n        h()\n        print(f'a in g after h: {a}')\n    a = 2\n    print(f'a in f before g called: {a}')\n    g()\n    print(f'a in f after g called: {a}')\n\n\nprint(f'a before f called: {a}')\nf()\nprint(f'a after f called: {a}')\nprint()\n\n# a before f called: 1\n# a in f before g called: 2\n# a in g before h: 3\n# a in h 4\n# a in g after h: 3\n# a in f after g called: 3\n# a after f called: 4\n\n# The global variable is altered in h scope and the local variable\n# defined in f is altered in the g scope using nonlocal keyword", "description": "nonlocal keyword usage", "section": "Scopes", "tags": ["global", "local", "scopes", "nonlocal"]}, {"title": "Reduce", "author": "Simon Ward-Jones (Carlos Aguila)", "snippet": "from functools import reduce\n\nlist_values = [1, 2, 4, 4, 2, 3, 7]\n\n\ndef add(a, b):\n    \"\"\"\n    Re-implementing the add function ...\n    \"\"\"\n    return a + b\n\n\nlist_sum = reduce(add, list_values)\nprint(list_sum)\n# 23\n\n# Example with lambda\nlist_product = reduce(lambda a, b: a * b, list_values)\nprint(list_product)\n# 1344", "description": "Reduce a list of values using a function", "section": "List", "tags": ["reduce", "functools"]}, {"title": "Dictionary from two lists", "author": "Carlos Aguila", "snippet": "words = ['zebra', 'bear', 'dog']\ncounts = [12, 43, 54]\ncount_look_up_dict = dict(zip(words, counts))\n\ncount_look_up_dict['zebra']\n# {'bear': 43, 'dog': 54, 'zebra': 12}", "description": "How to merge two lists into a dictionary", "section": "Dictionary", "tags": ["list", "dictionary"]}, {"title": "Flask sqlalchemy model", "author": "Simon Ward-Jones", "snippet": "from python_cookbook import db\nimport datetime\n\n\nclass Recipe(db.Model):\n    __tablename__ = 'recipes'\n    __searchable__ = ['title', 'snippet', 'author', 'description']\n\n    id = db.Column(db.Integer, primary_key=True)\n    title = db.Column(db.String(128))\n    author = db.Column(db.String(128))\n    snippet = db.Column(db.Text)\n    description = db.Column(db.Text)\n    section = db.Column(db.String(128))\n    added_time = db.Column(db.DateTime, default=datetime.datetime.utcnow())\n\n    def __init__(self, title, snippet, author, description, section):\n        self.title = title\n        self.author = author\n        self.snippet = snippet\n        self.description = description\n        self.section = section", "description": "An example sqlalchemy table class defenition", "section": "Sqlalchemy", "tags": ["sqlalchemy", "table", "model"]}, {"title": "Properties", "author": "Simon Ward-Jones", "snippet": "# A property allows logic to be built\n# into accessing/setting/deleting values\n\nclass Celsius:\n    def __init__(self, temperature = 0):\n        self.temperature = temperature\n\n    def to_fahrenheit(self):\n        return (self.temperature * 1.8) + 32\n\n    def get_temperature(self):\n        print(f\"Getting value {self._temperature}\")\n        return self._temperature\n\n    def set_temperature(self, value):\n        if value < -273:\n            raise ValueError(\"Temperature below -273 is not possible\")\n        print(f\"Setting value {value}\")\n        self._temperature = value\n\n    def delete_temperature(self):\n        print(f'deleted {self._temperature}')\n        self._temperature = 0\n\n    temperature = property(get_temperature,\n                           set_temperature,\n                           delete_temperature,\n                           doc=\"Temperature property\")\n\n# Create an instance of the celcius class\n# this also creates an instance of property class\nroom_temp = Celsius()\n\n# Set the temperature calls 'set_temperature'\nroom_temp.temperature = 5\n\n# Delete temperature calls 'delete_temperature'\ndel room_temp.temperature\nroom_temp.temperature = 23\n\n# This calls get_temperature\nprint(room_temp.temperature)\n\n\n# For more understanding on how properties work\n# please read up on descriptor protocol\n# and attribute lookup\n\n# output:\n# Setting value 0\n# Setting value 5\n# deleted 5\n# Setting value 23\n# Getting value 23\n# 23", "description": "Creating a property on a class", "section": "Objects", "tags": ["property", "__get__", "__set__", "__delete__"]}, {"title": "Timer", "author": "Simon Ward-Jones", "snippet": "import time\n\n\nclass Timer:\n\n    def __init__(self):\n        self.start_time = time.time()\n        self.end_time = time.time()\n        self._is_running = False\n\n    def start_timer(self):\n        \"\"\"starts/restarts the time\n        \"\"\"\n        self.start = time.time()\n        self._is_running = True\n\n    def start(self):\n        \"\"\"starts/restarts the time\n        \"\"\"\n        self.start = time.time()\n        self._is_running = True\n\n    def reset(self):\n        \"\"\"reset the time\n        \"\"\"\n        self.start_time = time.time()\n        self.end_time = time.time()\n        self._is_running = False\n\n    def stop(self):\n        \"\"\"stop the current time\n        \"\"\"\n        if self._is_running:\n            self.end = time.time()\n        else:\n            print(\"Can't Stop until you start\")\n        self._is_running = False\n\n    def get_time(self):\n        '''\n        Returns the time elapsed (Stops the counter if running).\n\n        Returns:\n            TYPE: string\n        '''\n        if self._is_running:\n            self.stop()\n        return self.end - self.start\n\n    def get_elapsed(self):\n        '''\n        Returns the time elapsed (Does not stop the counter).\n\n        Returns:\n            TYPE: string\n        '''\n        return time.time() - self.start\n\n    def get_time_hhmmss(self, duration):\n        \"\"\"Returns the duration in HH:mm:ss (Does not reset the counter).\n\n        Returns:\n            TYPE: Description\n        \"\"\"\n        m, s = divmod(duration, 60)\n        h, m = divmod(m, 60)\n        return f'{int(h):0>2}:{int(m):0>2}:{s:05.4f}'", "description": "Timer class with start and stop and display methods", "section": "Time", "tags": ["time", "class"]}, {"title": "List to comma seperated string", "author": "Simon Ward-Jones", "snippet": "example_list = ['The', 'Zebra', 'has', 5, 'stripes']\ncomma_sep_string = ','.join(map(str, example_list))\nquote_comma_sep_string = ','.join(f\"'{w}'\" for w in example_list)\n\nprint(comma_sep_string)\n# 'The,Zebra,has,5,stripes'\n\nprint(quote_comma_sep_string)\n# 'The','Zebra','has','5','stripes'\n# This can be useful for SQL", "description": "Convert a list to a comma seperated string", "section": "List", "tags": ["list", "comma", "string"]}, {"title": "Timer click", "author": "Simon Ward-Jones", "snippet": "import sys\nimport click\nfrom timer import Timer\n\n\n@click.command(help=\"Exit the time with ctrl + c\")\n@click.option('--countdown',\n              type=int,\n              help=\"Convert the timer to countdown with given seconds\")\ndef cli(countdown=None):\n    timer = Timer()\n    # print(timer)\n    timer.start_timer()\n    clean = 0\n    try:\n        if countdown:\n            while timer.get_elapsed() < countdown:\n                if timer.get_elapsed() < 2:\n                    elapsed = timer.get_time_hhmmss(\n                        countdown - timer.get_elapsed())\n                    print(f\"And They are off!!  {elapsed}\",\n                          end='\\r',\n                          flush=True)\n                elif clean == 0:\n                    print(\"                                   \",\n                          end='\\r')\n                    clean = 1\n                else:\n                    print(\n                        timer.get_time_hhmmss(countdown - timer.get_elapsed()),\n                        end='\\r',\n                        flush=True)\n        else:\n            while timer._is_running:\n                if timer.get_elapsed() < 2:\n                    elapsed = timer.get_time_hhmmss(timer.get_elapsed())\n                    print(f\"And They are off!! {elapsed}\",\n                          end='\\r',\n                          flush=True)\n                elif clean == 0:\n                    print(\"                                   \", end='\\r')\n                    clean = 1\n                else:\n                    print(timer.get_time_hhmmss(\n                        timer.get_elapsed()), end='\\r', flush=True)\n    except KeyboardInterrupt:\n        timer.stop()\n        print(\"                                   \",\n              end='\\r')\n        print(timer.get_time_hhmmss(timer.get_time()))\n        sys.exit()\n\n\nif __name__ == '__main__':\n    cli()", "description": "Count Down timer command line Tool", "section": "Click", "tags": ["click", "command line inteface"]}, {"title": "Multiprocessing on dataframes", "author": "Carlos Aguilar (Simon Ward-Jones)", "snippet": "import pandas as pd\nimport numpy as np\nimport multiprocessing as mp\nfrom functools import partial\n\n# Mutiprocessing with DATAFRAMES\n\n\ndef parallelSum(df, b, c, d):\n    a = df.TEST.sum()\n    dfA = pd.DataFrame(data=[{'results': a}])\n    print('A -> {},B -> {},C -> {},D -> {}'.format(a, b, c, d))\n    return dfA\n\n\ndf = pd.DataFrame(np.random.random_sample((50000, 1)), columns=['TEST'])\ndf_split = np.array_split(df, 100)\n\ncores = mp.cpu_count()\nmaxCores = cores - 1\npool = mp.Pool(maxCores)\n\n# use partial to fix the arguments that don't change\nworker_a = partial(parallelSum, b='b', c='c', d='d')\nresults = pool.map(worker_a, df_split)\npool.close()\npool.join()\n# The results are a list of dataframes\nextResults = pd.DataFrame()\nfor thisDF in results:\n    extResults = extResults.append(thisDF, ignore_index=True)", "description": "Demonstration of the multiprocessing library on Dataframes.", "section": "Processing", "tags": ["pandas", "", "boto3"]}, {"title": "Filter dataframe", "author": "Simon Ward-Jones", "snippet": "import pandas as pd\nimport numpy as np\nimport random\nfrom datetime import datetime\nfrom dateutil.relativedelta import relativedelta\n\n# First we create example dataframe\nr = random.Random(12)\n\n\ndef generate_random_date_in_last_year():\n    return (datetime.now() - relativedelta(days=365 * random.random())).date()\n\n\ndataframe = pd.DataFrame({\n    \"date_time\": [generate_random_date_in_last_year() for _ in range(10)],\n    \"animal\": ['zebra', 'zebra', 'zebra', 'zebra', 'lion', 'lion', 'lion',\n               'lion', 'rhino', 'rhino', ],\n    \"category\": ['stripy'] * 4 + ['dangerous'] * 6,\n    \"name\": ['Walter', 'Edmund', 'Gyles', 'John', 'Bartholomew', 'Frederyk',\n             'Raulf', 'Symond', 'Carlos', 'Arthur'],\n    \"weight\": [80 + 40 * r.random() for _ in range(10)],\n    \"favourite_integer\": [r.randint(0, 100) for _ in range(10)],\n    \"bad_column\": ['', 3, '', 1, None, 2, 23, 2, 3, 3],\n    'employed': [bool(r.randint(0, 1)) for i in range(10)]\n})\ndataframe.replace(to_replace='', value=np.nan, inplace=True)\n\n# We can filter the dataframe by specific values in a specific column\nfilter_list = ['lion', 'rhino']\ndataframe[dataframe['animal'].isin(filter_list)]\n\n# Alternatively we could use a map on the series\ndataframe[dataframe['animal'].map(lambda x: x in filter_list)]\n\n# or even this\ndataframe.query('animal in ' + str(filter_list))", "description": "Dataframe filtering by values", "section": "Pandas", "tags": ["pandas", "filter", "values"]}, {"title": "Save metadata", "author": "Carlos Aguilar", "snippet": "import os\nimport json\nimport datetime as dt\n\n\ndef save_metadata(file_path, short_description, file_comments,\n                  file_generation, file_directions):\n    \"\"\"Save file meta information\n\n    Add useful information about the file as a json summary.\n\n    Args:\n        file_path (str): Current path to the file.\n        short_description (str): Brief description of the file.\n        file_comments (str): A bit more detailed description.\n        file_generation (str): How was the file generated.\n        file_directions (str): How to use the file or what to expect when loaded.\n\n\n    Category: Python\n    Topic: Metadata\n\n    \"\"\"\n\n    stat_info = os.stat(file_path)\n    size_MB = round(statinfo.st_size / (10**6))\n    [fPath, fName] = os.path.split(file_path)\n\n    format = '%d_%m_%Y_%H_%M_%S'\n    creation_time = dt.datetime.today().strftime(format)\n\n    metadata = {'description': short_description,\n                'comments': file_comments,\n                'filename': fName,\n                'folder': fPath,\n                'creationTime': creation_time,\n                'directions': file_directions,\n                'generation': file_generation,\n                'sizeMB': sizeMB}\n\n    jsonFName = file_path.replace(os.path.splitext(fName)[1], '.json')\n    with open(jsonFName, 'w') as outfile:\n        json.dump(metadata, outfile)\n\n\n\"\"\"\nExample:\n    shortDescription = 'CatBoost model'\n    fileComments     = '''This file includes a catboost model to predict the number of coffees that the Data Science team consumes in a week'''\n    fileGeneration   = 'File generated with ' + os.path.abspath(__file__) + '(the script)'\n    fileDirections   = '''This pickle file will get loaded as a dataframe of size ''' + \\\n    str(model.shape) + \\\n    '''. Read this data with utils.readPickleFile(current_model);'''\n    filePath = current_model\n\n    saveMetadata(filePath, shortDescription, fileComments, \\\n        fileGeneration, fileDirections)\n\"\"\"", "description": "Add metadata information to files, so they can be easily summarised, ie: latest version, contents, ways of generating\n    or ways of using it.", "section": "Reading And Writing", "tags": ["write", "metadata", "json"]}, {"title": "Merge lists into list of tuples", "author": "Carlos Aguila", "snippet": "list_a = [1, 2, 3, 4]\nlist_b = [5, 6, 7, 8]\n\nlist_of_tuples = list(zip(list_a, list_b))\n# [(1, 5), (2, 6), (3, 7), (4, 8)]", "description": "How to merge two lists into a list of tuples", "section": "List", "tags": ["list", "flatten", "merge", "tuple"]}, {"title": "Threaded loop", "author": "Simon Ward-Jones", "snippet": "import threading\nfrom datetime import datetime\nimport logging\nimport time\n\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(threadName)s - %(message)s\",\n    datefmt=\"%m/%d/%YT%H:%M:%S.%f\")\n\n\nclass Loop():\n    def __init__(self, interval, function, args=(), kwargs={}):\n        self.stop_event = threading.Event()\n        self.function = function\n        self.args = args\n        self.kwargs = kwargs\n        self.interval = interval\n        self.is_running = False\n\n    def _repeat_function(self):\n        next_time = time.time() + self.interval\n        actual_finish = time.time()\n        # Note the while repeats every second assuming\n        # the function complets in under a second\n        while not self.stop_event.wait(max(0, next_time - actual_finish)):\n            next_time = time.time() + self.interval\n            logging.info(\n                f\"Calling {self.function.__name__} with args \"\n                f\"{self.args} and kwargs {self.kwargs} at time : \"\n                f\"{datetime.utcnow().strftime('%H:%M:%S.%f')}\")\n            self.function(*self.args, **self.kwargs)\n            actual_finish = time.time()\n\n    def start(self):\n        if not self.is_running:\n            self.stop_event = threading.Event()\n            t = threading.Thread(target=self._repeat_function)\n            t.daemon = True\n            t.start()\n            self.is_running = True\n            logging.info('Started loop')\n\n    def stop(self):\n        if self.is_running:\n            self.stop_event.set()\n            self.is_running = False\n            logging.info('Stopped loop')\n\n\ndef example_func(name, height=3):\n    logging.info(f'name {name}, height {height}')\n    return 'done'\n\n\nif __name__ == '__main__':\n    simon_loop = Loop(interval=1,\n                      function=example_func,\n                      args=('simon',),\n                      kwargs={\"height\": 44}\n                      )\n    simon_loop.start()\n    time.sleep(5)\n    simon_loop.stop()\n    time.sleep(5)\n    simon_loop.start()\n    time.sleep(5)\n    simon_loop.stop()", "description": "Repeatedly run a function on thread", "section": "Threading", "tags": ["threading", "loop", "setinterval"]}, {"title": "Iterate on directory progress bar", "author": "Carlos Aguila (Simon Ward-Jones)", "snippet": "import tqdm as tqdm\n# tqdm is a progress bar library\nimport os\nimport time\n\nfor file in tqdm.tqdm(os.listdir('.')):\n    # here you might actually want to do more than sleep\n    time.sleep(0.5)", "description": "How to iterate on a directory with a progress bar", "section": "Progress Bar", "tags": ["tqdm", "directory", "progress bar"]}, {"title": "Set operations", "author": "Carlos Aguila", "snippet": "list_1 = [2, 3, 4, 5]\nlist_2 = [3, 4, 5, 6]\nset_1 = set(list_1)\nset_2 = set(list_2)\n\n# Set operations:\nset_1_without_set_2 = set_1 - set_2\nset_1_union_set_2 = set_1 | set_2\nset_1_intersect_set_2 = set_1 & set_2\nsymmetric_difference = set_1 ^ set_2  # In set 1 or set 2 but not both\n\nprint(set_1_without_set_2)\n# {2}\nprint(set_1_union_set_2)\n# {2, 3, 4, 5, 6}\nprint(set_1_intersect_set_2)\n# {3, 4, 5}\nprint(symmetric_difference)\n# {2, 6}", "description": "How to use basic set operations", "section": "Set", "tags": ["set", "list"]}, {"title": "Map functions on list", "author": "Carlos Aguila (Simon Ward-Jones)", "snippet": "example_dir_list = ['dictionary_from_two_lists.py',\n                    'flask_routing.py',\n                    'flask_sqlalchemy_model.py',\n                    'flatten_list_of_lists.py']\n\ndashed_names = [*map(lambda x: x.replace('_', '-'),\n                     example_dir_list)]\n# ['dictionary-from-two-lists.py',\n#  'flask-routing.py',\n#  'flask-sqlalchemy-model.py',\n#  'flatten-list-of-lists.py']\n\n# Another example\nsquares = list(map(lambda x: x * x, [0, 1, 2, 3, 4]))\n# [0, 1, 4, 9, 16]", "description": "How to apply functions to a list using map", "section": "Map", "tags": ["map", "list", "lambda"]}, {"title": "Iterate on directory file extension", "author": "Simon Ward-Jones", "snippet": "import os\nimport glob\n\n# Method 1\n# use the endswith method on a string\nfor file in os.listdir('.'):\n    if file.endswith('.py'):\n        print(file)\n\n\n# Method 2\n# Use the glob library\nfor file in glob.glob(\"*.py\"):\n    print(file)", "description": "How to iterate on a directory filtering by\n    file extension", "section": "Os", "tags": ["file extension", "directory", "os", "glob"]}, {"title": "Copy and paste", "author": "Simon Ward-Jones (Carlos Aguila)", "snippet": "import clipboard\nimport pyperclip\n\n# Method 1\nclipboard.copy('A wild zebra')\nclipboard.paste()\n\n# Method 2\npyperclip.copy('A wild zebra')\npyperclip.paste()", "description": "Copy and paste", "section": "Helpers", "tags": ["copy", "paste"]}, {"title": "Pivot dataframe", "author": "Simon Ward-Jones (Carlos Aguila)", "snippet": "import pandas as pd\nimport numpy as np\nimport random\nfrom datetime import datetime\nfrom dateutil.relativedelta import relativedelta\n\n# First we create example dataframe\nr = random.Random(12)\n\n\ndef generate_random_date_in_last_year():\n    return (datetime.now() - relativedelta(days=365 * random.random())).date()\n\n\ndataframe = pd.DataFrame({\n    \"date_time\": [generate_random_date_in_last_year() for _ in range(10)],\n    \"animal\": ['zebra', 'zebra', 'zebra', 'zebra', 'lion', 'lion', 'lion',\n               'lion', 'rhino', 'rhino', ],\n    \"category\": ['stripy'] * 4 + ['dangerous'] * 6,\n    \"name\": ['Walter', 'Edmund', 'Gyles', 'John', 'Bartholomew', 'Frederyk',\n             'Raulf', 'Symond', 'Carlos', 'Arthur'],\n    \"weight\": [80 + 40 * r.random() for _ in range(10)],\n    \"favourite_integer\": [r.randint(0, 100) for _ in range(10)],\n    \"bad_column\": ['', 3, '', 1, None, 2, 23, 2, 3, 3],\n    'employed': [bool(r.randint(0, 1)) for i in range(10)]\n})\ndataframe.replace(to_replace='', value=np.nan, inplace=True)\n\n# Pivot table\npivot_dataframe = pd.pivot_table(dataframe,\n                                 values=['weight', 'bad_column'],\n                                 index='animal',\n                                 columns='employed',\n                                 aggfunc=[np.mean])\npivot_dataframe\n\n#          | mean       | mean       | mean               | mean\n#          | bad_column | bad_column | weight             | weight\n# employed | False      | True       | False              | True\n# animal   |            |            |                    |\n# lion     | 9.0        |            | 99.45534245035707  | 80.43441772360272\n# rhino    | 3.0        |            | 105.84099383532836 |\n# zebra    | 3.0        | 1.0        | 103.97938203294188 | 85.70401411701471", "description": "Pivot table from Dataframe", "section": "Pandas", "tags": ["pivot", "pandas", "pivot table"]}, {"title": "Attribute lookup", "author": "Simon Ward-Jones", "snippet": "# A descriptor has the __get__ magic function defined\n# A data descriptor has the __get__ and at\n# least one of __set__ or __delete__\n\nclass Mood():\n    \"\"\" descriptor\"\"\"\n    def __get__(self, instance, owner):\n        print(f'__get__ called with self, instance, owner ='\n              f'{self, instance, owner}')\n        return 'Happy'\n    def __repr__(self):\n        return f'<mood>'\n\n\nclass Age():\n    \"\"\" data descriptor\"\"\"\n    def __init__(self):\n        print(f'initialise age property (note no value yet)')\n\n    def __get__(self, instance, owner):\n        print(f'__get__ called with self, instance, owner = '\n              f'{self, instance, owner}')\n        return instance._age\n\n    def __set__(self, instance, value):\n        instance._age = value\n\n    def __repr__(self):\n        return f'<Age>'\n\n\nclass Human():\n    lung_count = 2\n    age = Age()\n    mood = Mood()\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n    def __repr__(self):\n        return f'<Human name={self.name}>'\n    def __getattr__(self, attr):\n        print('Fails looking for {attr} on {self}')\n        return 'FAIL'\n\n\n# Descriptors are useful because they allow logic on get/set/delete\n# Soooo how does attribute look up work?\n\n###################\n# For an object\n###################\n\n# Say we are looking up attribute called attribute on a class\n# instance called instance  with class called Class\n\n# The look up goes through the below:\n\n# 1- Class.__dict__ has data descriptor called attribute\n# return Class.__dict__['attribute'].__get__(instance,Class)\n\n# 2- attribute in instance.__dict__\n# return instance.__dict__['attribute']\n\n# 3- attribute in Class.__dict__ (but has __get__ not __set__ or __delete__)\n# return Class.__dict__['attribute'].__get__(instance,Class)\n\n# 4- attribute in Class.__dict__ (but has NO __get__ )\n# return Class.__dict__['attribute']\n\n# 5- finnaly call Class.__getattr__\n\n\n# To see this look at the examples\n# note type(fred) == Human\n\nfred = Human(name='Fred', age=32)\nassert type(fred) == Human\n# initialise age property (note no value yet)\n\n\nprint('Scenraio 1')\nprint(fred.age)\n# __get__ called with self, instance, owner =\n# (<Age>, <Human name=Fred>, <class '__main__.Human'>)\n# 32\n\n# Explained\n# Note fred is an object and age is a data descriptor so we end up in\n# scenraio 1\nassert fred.age == type(fred).__dict__['age'].__get__(fred, Human)\n\n\n# print(fred.name)\nprint('Scenraio 2')\nprint(fred.name)\n# Fred\n\n# Explained\n# Note fred is an object and name is not a descriptor so we end up in\n# scenraio 2\nassert fred.name == fred.__dict__['name']\n\n\nprint('Scenraio 3')\nprint(fred.mood)\n# __get__ called with self, instance, owner =\n# (<mood>, <Human name=Fred>, <class '__main__.Human'>)\n# Happy\n\n# Explained\n# Note fred is an object and mood is a descriptor so we end up in\n# scenraio 3\nassert fred.mood == type(fred).__dict__['mood'].__get__(fred, Human)\n\n\nprint('Scenraio 4')\nprint(fred.lung_count)\n# 2\n\n# Explained\n# Note fred is an object and lung_count is not a descriptor so we end up in\n# scenraio 4\nassert fred.lung_count == type(fred).__dict__['lung_count']\n\nprint('Scenraio 5')\nprint(fred.height)\n# Fails looking for {attr} on {self}\n# FAIL\n\n# Explained\n# Note fred is an object and height is not in fred.__dict__ or Human.__dict__\n# which leaves us in scenraio 5", "description": "Attribute access", "section": "Objects", "tags": ["descriptor protocol", "__get__", "__set__", "__delete__"]}, {"title": "Reload a module", "author": "Carlos Aguila (Simon Ward-Jones)", "snippet": "import imp\n\n# To import a module use the reload method of imp package\nimp.reload(imp)", "description": "How to reload a module", "section": "Import", "tags": ["import"]}, {"title": "Zen", "author": "David Hewitt", "snippet": "import this\n# Beautiful is better than ugly.\n# Explicit is better than implicit.\n# Simple is better than complex.\n# Complex is better than complicated.\n# Flat is better than nested.\n# Sparse is better than dense.\n# Readability counts.\n# Special cases aren't special enough to break the rules.\n# Although practicality beats purity.\n# Errors should never pass silently.\n# Unless explicitly silenced.\n# In the face of ambiguity, refuse the temptation to guess.\n# There should be one-- and preferably only one --obvious way to do it.\n# Although that way may not be obvious at first unless you're Dutch.\n# Now is better than never.\n# Although never is often better than *right* now.\n# If the implementation is hard to explain, it's a bad idea.\n# If the implementation is easy to explain, it may be a good idea.\n# Namespaces are one honking great idea -- let's do more of those!\n\n\n# And just for a little bit of lightheartedness\nimport antigravity", "description": "The Zen of Python.", "section": "Easter Eggs", "tags": ["zen", "antigravity"]}, {"title": "Flask routing", "author": "Simon Ward-Jones", "snippet": "from flask import Blueprint, jsonify, \\\n    render_template, request\nfrom .model import Recipe\nfrom flask_wtf import FlaskForm\nfrom wtforms import StringField\nfrom wtforms.validators import InputRequired\n\n\ncrud = Blueprint('crud', __name__)\n\n\n@crud.route(\"/\", methods=['GET', 'POST'])\ndef list():\n    recipes = Recipe.query.all()\n    next_page_token = None\n    form = SearchForm()\n    if request.method == 'POST':\n        if form.validate():\n            print('Search Hit', request.method, form.query.data)\n            recipes = Recipe.query.whoosh_search(form.query.data).all()\n            render_template(\"list.html\", recipes=recipes,\n                            next_page_token=next_page_token, form=form)\n        else:\n            return render_template(\"list.html\", recipes=recipes,\n                                   next_page_token=next_page_token, form=form)\n\n    return render_template(\n        \"list.html\",\n        recipes=recipes,\n        next_page_token=next_page_token,\n        form=form)\n\n\n@crud.route('/<id>')\ndef snippet(id):\n    recipe = Recipe.query.get(id)\n    return render_template(\"view.html\", recipe=recipe, form=SearchForm())\n\n\n@crud.route('/<id>/data')\ndef snippet2(id):\n    recipe = Recipe.query.get(id)\n\n    return jsonify({'title': recipe.title,\n                    'author': recipe.author,\n                    'snippet': recipe.snippet})\n\n\nclass SearchForm(FlaskForm):\n    query = StringField('Search', validators=[InputRequired()])", "description": "An example route definition module", "section": "Flask", "tags": ["flask", "routes"]}, {"title": "Split dataframe", "author": "Simon Ward-Jones (Carlos Aguila)", "snippet": "import pandas as pd\nimport numpy as np\n\ndataframe = pd.DataFrame([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], columns=['TEST'])\ndf_split = np.array_split(dataframe, 3)\n# Gives a list with the chunked DF\nfor df in df_split:\n    print(df)\n\n#    TEST\n# 0     1\n# 1     2\n# 2     3\n# 3     4\n#    TEST\n# 4     5\n# 5     6\n# 6     7\n# 7     8\n#     TEST\n# 8      9\n# 9     10\n# 10    11", "description": "Chunk a Pandas DataFrame", "section": "Pandas", "tags": ["pandas", "numpy", "split", "chunk"]}, {"title": "Flatten list of lists", "author": "Simon Ward-Jones (Carlos Aguila)", "snippet": "import itertools\n\n# Method 1\n# For a list of lists simply use a list comprehension\n\nexample_string_list = ['an', 'example', 'list', 'of', 'strings']\nexample_int_list = [123, 34, 3, 12, 32, 14]\nexample_nested_list = [example_string_list, example_int_list]\n\nflattened = [item for sublist in example_nested_list for item in sublist]\n# ['an', 'example', 'list', 'of', 'strings', 123, 34, 3, 12, 32, 14]\n\n\n# Method 2\n# Again for same example but using built in method from itertools\n\nflattened = list(itertools.chain.from_iterable(example_nested_list))\n# ['an', 'example', 'list', 'of', 'strings', 123, 34, 3, 12, 32, 14]\n\n\n# Method 3\n# For a more complex example nested to an arbitrary depth we need a\n# recursive function\n\ndef flatten(nested_lists):\n    flattened_list = []\n    for element in nested_lists:\n        if isinstance(element, list):\n            for sub_element in flatten(element):\n                flattened_list.append(sub_element)\n        else:\n            flattened_list.append(element)\n    return flattened_list\n\n\nexample_deeply_nested_list = [\n    1, 2, 4, [1, 2, 3, 5, 67, [1, 2, 3, 4, [1, 2, 3, 4]]]]\nflattened = flatten(example_deeply_nested_list)\n\n# [1, 2, 4, 1, 2, 3, 5, 67, 1, 2, 3, 4, 1, 2, 3, 4]", "description": "How to flatten a list of lists", "section": "List", "tags": ["list", "flatten"]}, {"title": "Make and delete directory", "author": "Simon Ward-Jones", "snippet": "import os\nimport shutil\n\n# # Make a directory\ndirectory = os.path.join(os.curdir, \"temporary_zebra\")\nif not os.path.exists(directory):\n    os.makedirs(directory)\n\n# Delete the directory\nif os.path.exists(directory):\n    shutil.rmtree(directory)\n\n\n# Both of the above could be acheived with raw system commands:\nif not os.path.exists(directory):\n    os.system(f'mkdir {directory}')\n\n# # Delete the directory\nif os.path.exists(directory):\n    os.system(f'rm -rf {directory}')", "description": "How to make and delete direcotries", "section": "Os", "tags": ["os", "direcotry", "shutil"]}]